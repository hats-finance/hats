import React, { useState } from "react";
import "../../styles/Vulnerability/Submit.scss";
import sha256 from "sha256";
import { createTransaction, submitVulnerability } from "../../actions/contractsActions";
import { useDispatch, useSelector } from "react-redux";
import { ICardData, initData } from "./VulnerabilityAccordion";
import Loading from "../Shared/Loading";
import { fromWei, isProviderAndNetwork } from "../../utils";
import { RootState } from "../../reducers";
import axios from "axios";
import { TELEGRAM_BOT_URL } from "../../settings";
import { toggleNotification } from "../../actions";
import { DEFAULT_ERROR_MESSAGE, NotificationType } from "../../constants/constants";
import { ISeverity } from "../../types/types";
import millify from "millify";
const openpgp = require("openpgp");

interface IProps {
  cards: { [id: number]: ICardData }
  setCards: Function
}

export default function Submit(props: IProps) {
  const { cards } = props;
  const dispatch = useDispatch();
  const isVerified = cards[1].verified && cards[2].verified && cards[3].verified;
  const [inTransaction, setInTransaction] = useState(false);
  const provider = useSelector((state: RootState) => state.web3Reducer.provider);
  const vault = cards[1].data;

  const prizes = React.useCallback(vault.description?.severities?.map((severity: ISeverity, index: number) => {
    let rewardPrice = "-";
    const rewardPercentage = (Number(vault.rewardsLevels[severity.index]) / 10000) * 100;
    if (vault.tokenPrice && vault.honeyPotBalance) {
      rewardPrice = millify(Number(fromWei(vault.honeyPotBalance)) * rewardPercentage * vault.tokenPrice);
    }

    return (
      <tr key={index}>
        <td>{severity.name.toUpperCase()}</td>
        <td><b>{`${rewardPercentage}%`}</b> of Vault <span>&#8776; {`$${rewardPrice}`}</span></td>
        <td>NFT ???</td>
      </tr>
    )
  }), [cards[1].verified, vault]);

  const submit = async () => {
    setInTransaction(true);
    const encryptedData = await pgpData();
    const sha256Encrypted = sha256(encryptedData.replace(/\s+/g, ''));
    try {
      await createTransaction(
        async () => await submitVulnerability(vault.masterAddress, sha256Encrypted),
        async () => {
          await axios.post(TELEGRAM_BOT_URL, { msg: encryptedData });
          localStorage.removeItem("submitVulnerabilityData");
          props.setCards(initData);
        },
        () => { },
        dispatch,
        "The vulnerability was submitted successfully", 2);
    } catch (err) {
      console.error(err);
      dispatch(toggleNotification(true, NotificationType.Error, err?.message ?? DEFAULT_ERROR_MESSAGE));
    }
    setInTransaction(false);
  }

  const pgpData = async () => {
    const dataToEncrypt = `
    Project Name: ${vault.projectName}
    Title: ${cards[3].data.title}
    Description: ${cards[3].data.description}
    Telegram username: ${cards[2].data.username}
    `
    const publicKeyArmored = `${vault.description["communication-channel"]["pgp-pk"]}`;

    const publicKey = await openpgp.readKey({ armoredKey: publicKeyArmored });

    const encrypted = await openpgp.encrypt({
      message: openpgp.Message.fromText(dataToEncrypt),
      publicKeys: publicKey
    });
    return encrypted;
  }

  return <div className={inTransaction ? "submit-wrapper loading card-content" : "submit-wrapper card-content"}>
    <div><span className="arrow-text">{`-->`}</span>After submitting a vulnerability you will recieve the committee reciept and processing timeline via Telegram. The committee triaged is estimated between 5-7 days</div>
    <div><span className="arrow-text">{`-->`}</span>{cards[1].verified ? "Prizes are allocated by vulnerability level:" : "Please choose project to view prizes"}</div>
    {cards[1].verified &&
      <table>
        <tbody>
          <tr>
            <th>Level</th>
            <th>Prize</th>
            <th>Added Prize</th>
          </tr>
          {prizes}
        </tbody>
      </table>}
    <button disabled={!isVerified || inTransaction || !isProviderAndNetwork(provider)} onClick={submit}>SUBMIT</button>
    {inTransaction && <Loading />}
  </div>
}
